<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Power Tetris Pro v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-dark: #0f172a;
            --accent-blue: #38bdf8;
            --accent-purple: #818cf8;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-amber: #f59e0b;
        }

        body {
            background-color: var(--bg-dark);
            color: #f8fafc;
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            padding: 10px;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }

        .header-box {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            background: #020617;
            border: 3px solid #334155;
            border-radius: 8px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            min-height: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controller {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 15px 10px 40px 10px;
            background: #1e293b;
            border-top: 2px solid #334155;
            flex-shrink: 0;
        }

        .d-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left down right";
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .action-pad {
            display: grid;
            grid-template-areas:
                "hold rotate item"
                "drop drop drop";
            grid-template-columns: 1fr 1.2fr 1fr;
            gap: 8px;
        }

        .btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
            font-weight: 800;
            color: white;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.3);
            transition: transform 0.05s, box-shadow 0.05s;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.3);
            background-color: #475569;
        }

        .btn-move {
            background: #475569;
            height: 55px;
            font-size: 24px;
        }

        .btn-rotate {
            background: var(--accent-purple);
            grid-area: rotate;
            height: 65px;
            font-size: 28px;
        }

        .btn-hold {
            background: #6366f1;
            grid-area: hold;
            height: 55px;
            font-size: 14px;
        }

        .btn-item {
            background: var(--accent-amber);
            grid-area: item;
            height: 55px;
            font-size: 14px;
        }

        .btn-drop {
            background: var(--accent-green);
            grid-area: drop;
            height: 52px;
            font-size: 18px;
            margin-top: 10px;
            margin-bottom: 5px;
        }

        .item-active {
            animation: glow 0.8s infinite alternate;
        }

        #bgm-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 200;
            transition: 0.2s;
        }

        #bgm-toggle.muted {
            border-color: #475569;
            color: #475569;
        }

        @keyframes glow {
            from {
                box-shadow: 0 4px 0 rgba(0, 0, 0, 0.3), 0 0 5px var(--accent-amber);
            }

            to {
                box-shadow: 0 4px 0 rgba(0, 0, 0, 0.3), 0 0 20px var(--accent-amber);
            }
        }

        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .switch-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: 0.2s;
            z-index: 150;
        }

        .switch-btn:hover {
            background: var(--accent-blue);
            color: black;
            box-shadow: 0 0 10px var(--accent-blue);
        }

        #switch-left {
            left: 10px;
        }

        #switch-right {
            right: 10px;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .shake {
            animation: shake 0.3s;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-content {
            background: #1e293b;
            border: 2px solid var(--accent-blue);
            border-radius: 16px;
            max-width: 400px;
            width: 100%;
            padding: 24px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #94a3b8;
            cursor: pointer;
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .help-item:last-child {
            border-bottom: none;
        }

        .help-icon {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .help-text h3 {
            font-weight: 800;
            color: var(--accent-blue);
            font-size: 0.9rem;
            margin: 0;
        }

        .help-text p {
            font-size: 0.75rem;
            color: #cbd5e1;
            margin: 2px 0 0 0;
            line-height: 1.4;
        }

        #best-score-container {
            margin-top: 15px;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <header>
            <div class="header-box">
                <div class="text-[9px] text-slate-400">HOLD</div>
                <canvas id="hold-canvas" width="40" height="40" class="mx-auto"></canvas>
            </div>
            <div class="header-box">
                <div class="text-[9px] text-slate-400">NEXT</div>
                <canvas id="next-canvas" width="40" height="40" class="mx-auto"></canvas>
            </div>
            <div class="header-box">
                <div class="text-[9px] text-slate-400">SCORE</div>
                <div id="score" class="text-sm font-bold text-sky-400">0</div>
            </div>
            <div class="header-box">
                <div class="text-[9px] text-slate-400">LINES</div>
                <div id="lines" class="text-sm font-bold text-indigo-400">0</div>
            </div>
        </header>

        <div id="canvas-wrapper">
            <canvas id="game-canvas"></canvas>
            <div id="overlay">
                <h1 class="text-4xl font-black mb-2 text-white italic tracking-tighter">POWER TETRIS</h1>
                <p class="text-slate-400 text-sm mb-8 font-bold text-center">ELITE MOBILE EDITION</p>
                <button id="start-btn"
                    class="bg-indigo-500 hover:bg-indigo-400 text-white px-12 py-4 rounded-2xl font-black text-xl shadow-[0_6px_0_#4338ca] transition-all active:translate-y-1 active:shadow-none">
                    START
                </button>
                <div id="best-score-container" class="hidden">
                    <div class="text-[10px] text-slate-400">BEST SCORE</div>
                    <div id="best-score" class="text-xl font-bold text-amber-400">0</div>
                </div>
                <div id="help-btn"
                    class="mt-8 text-slate-400 border border-slate-700 w-10 h-10 rounded-full flex items-center justify-center font-bold cursor-pointer hover:bg-slate-800 transition-colors">
                    ?</div>
                <div id="switch-left" class="switch-btn">‚Üê</div>
                <div id="switch-right" class="switch-btn">‚Üí</div>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
        <div class="modal-content">
            <span id="close-modal" class="modal-close">&times;</span>
            <h2 class="text-xl font-black mb-6 text-center text-white italic">TETRO GUIDE</h2>

            <div class="mb-4 text-xs font-bold text-slate-500 uppercase tracking-widest border-b border-slate-700 pb-1">
                Special Minos</div>
            <div class="help-item">
                <img src="images/„É¢„Éé„É™„Çπ.png" class="help-icon">
                <div class="help-text">
                    <h3>MONOLITH</h3>
                    <p>ÈáçÂéö„Å™„Éñ„É≠„ÉÉ„ÇØ„ÄÇ50%„ÅßMonolith„Å®„Åó„Å¶Ë®≠ÁΩÆ„Åï„Çå„Çã„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <img src="images/„Ç≤„É´.png" class="help-icon">
                <div class="help-text">
                    <h3>GEL</h3>
                    <p>Ë®≠ÁΩÆÂæå„ÄÅÈöôÈñì„Åå„ÅÇ„ÇãÈôê„Çä‰∏ã„Å∏„Å®Ê∫∂„ÅëËêΩ„Å°„Å¶„ÅÑ„Åè„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <img src="images/„Ç¥„Éº„Çπ„Éà.png" class="help-icon">
                <div class="help-text">
                    <h3>GHOST</h3>
                    <p>Ëá™Ë∫´„Å®„ÄÅ„Åù„ÅÆÁõ¥‰∏ã„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÊ∂à„ÅóÂéª„Å£„Å¶Ê∂àÊªÖ„Åô„Çã„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <img src="images/„Ç¥„Éº„É¨„É†.png" class="help-icon">
                <div class="help-text">
                    <h3>GOLEM</h3>
                    <p>ÁùÄÂú∞ÊôÇ„Å´Âú∞Èüø„Åç„ÇíËµ∑„Åì„Åó„ÄÅÁúü‰∏ã„ÅÆÈöôÈñì„ÇíÂüã„ÇÅ„Çã„Çà„ÅÜ„Å´„Éñ„É≠„ÉÉ„ÇØ„ÇíÊäº„ÅóÊΩ∞„Åô„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <img src="images/„ÅØ„Å¶„Å™.png" class="help-icon">
                <div class="help-text">
                    <h3>MYSTERY</h3>
                    <p>Êé•Âú∞„Åó„ÅüÁû¨Èñì„ÄÅ‰ªñ„ÅÆ4„Å§„ÅÆËÉΩÂäõ„ÅÆ„ÅÑ„Åö„Çå„Åã„Å´Â§âÂåñ„Åô„Çã„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <img src="images/„Éò„É≥„Ç¨„Éº.png" class="help-icon">
                <div class="help-text">
                    <h3>HENGER</h3>
                    <p>ËêΩ‰∏ã‰∏≠„Å´ÂõûËª¢„Éú„Çø„É≥„ÇíÊäº„Åô„Å®„ÄÅÂà•„ÅÆÂΩ¢Áä∂„Å´„Éà„É©„É≥„Çπ„Éï„Ç©„Éº„É†„Åô„Çã„ÄÇ</p>
                </div>
            </div>

            <div
                class="mt-8 mb-4 text-xs font-bold text-slate-500 uppercase tracking-widest border-b border-slate-700 pb-1">
                Items (Cleared Line)</div>
            <div class="help-item">
                <div
                    class="help-icon flex items-center justify-center bg-amber-500 rounded-lg font-black text-[10px] text-white">
                    BOMB</div>
                <div class="help-text">
                    <h3>BOMB</h3>
                    <p>Ë®≠ÁΩÆÂ†¥ÊâÄ„Çí‰∏≠ÂøÉ„Å´Âë®Âõ≤2„Éû„Çπ„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ†¥Â£ä„Åô„Çã„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <div
                    class="help-icon flex items-center justify-center bg-emerald-500 rounded-lg font-black text-[10px] text-white">
                    SLOW</div>
                <div class="help-text">
                    <h3>SLOW</h3>
                    <p>8ÁßíÈñì„ÄÅ„Éü„Éé„ÅÆËêΩ‰∏ãÈÄüÂ∫¶„ÅåÂ§ßÂπÖ„Å´‰Ωé‰∏ã„Åô„Çã„ÄÇ</p>
                </div>
            </div>
            <div class="help-item">
                <div
                    class="help-icon flex items-center justify-center bg-indigo-500 rounded-lg font-black text-[10px] text-white">
                    CLEAR</div>
                <div class="help-text">
                    <h3>CLEAR</h3>
                    <p>„Éï„Ç£„Éº„É´„Éâ‰∏ä„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí‰∏ÄÊéÉ„Åô„Çã„ÄÇ</p>
                </div>
            </div>
        </div>
    </div>

    <div id="bgm-toggle">üîä</div>
    </div>

    <div class="controller">
        <div class="d-pad">
            <div class="btn btn-move" style="grid-area: left" id="btn-left">‚Üê</div>
            <div class="btn btn-move" style="grid-area: down" id="btn-down">‚Üì</div>
            <div class="btn btn-move" style="grid-area: right" id="btn-right">‚Üí</div>
        </div>

        <div class="action-pad">
            <div class="btn btn-hold" id="btn-hold">HOLD</div>
            <div class="btn btn-rotate" id="btn-rotate">‚Üª</div>
            <div class="btn btn-item" id="btn-item">
                <div id="item-label" class="text-[10px]">ITEM</div>
                <div id="item-name" class="text-[11px] leading-tight">NONE</div>
            </div>
            <div class="btn btn-drop" id="btn-drop">HARD DROP</div>
        </div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 20;
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-canvas');
        const holdCtx = holdCanvas.getContext('2d');
        const overlay = document.getElementById('overlay');

        // --- Sound System (Synthesized) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        class SoundSystem {
            constructor() {
                this.isPlayingBGM = false;
                this.bgmTimer = null;
                this.currentNote = 0;
                this.isMuted = localStorage.getItem('tetris_bgm_muted') === 'true';
                this.melody = [
                    { f: 261.63, d: 0.25 }, { f: 329.63, d: 0.25 }, { f: 392.00, d: 0.25 }, { f: 523.25, d: 0.25 },
                    { f: 440.00, d: 0.25 }, { f: 349.23, d: 0.25 }, { f: 392.00, d: 0.5 },
                    { f: 293.66, d: 0.25 }, { f: 349.23, d: 0.25 }, { f: 440.00, d: 0.25 }, { f: 587.33, d: 0.25 },
                    { f: 493.88, d: 0.25 }, { f: 392.00, d: 0.25 }, { f: 523.25, d: 0.5 }
                ];
            }
            async playBGM() {
                if (this.isPlayingBGM || this.isMuted) return;
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                this.isPlayingBGM = true;
                this.loopBGM();
            }
            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('tetris_bgm_muted', this.isMuted);
                if (this.isMuted) {
                    this.stopBGM();
                } else if (!isGameOver) {
                    this.playBGM();
                }
                return this.isMuted;
            }
            stopBGM() {
                this.isPlayingBGM = false;
                if (this.bgmTimer) clearTimeout(this.bgmTimer);
            }
            loopBGM() {
                if (!this.isPlayingBGM || this.isMuted) return;
                const note = this.melody[this.currentNote];
                if (note.f > 0) this.tone(note.f, note.d * 0.8, 'sine', 0.08); // „Çà„ÇäÊæÑ„Çì„Å†Èü≥Ëâ≤„Å´
                this.currentNote = (this.currentNote + 1) % this.melody.length;
                this.bgmTimer = setTimeout(() => this.loopBGM(), note.d * 1000);
            }
            tone(freq, dur, type = 'sine', vol = 0.1) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
                osc.start();
                osc.stop(audioCtx.currentTime + dur + 0.1);
            }
            playLineClear() {
                const now = audioCtx.currentTime;
                [440, 554.37, 659.25, 880].forEach((f, i) => {
                    this.tone(f, 0.4, 'sine', 0.1);
                });
            }
            playTetrisBonus() {
                const now = audioCtx.currentTime;
                // Ë±™ËèØ„Å™‰∏äÊòá„Ç¢„É´„Éö„Ç∏„Ç™
                const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98, 2093.00];
                notes.forEach((f, i) => {
                    setTimeout(() => {
                        this.tone(f, 0.6, 'sine', 0.15);
                    }, i * 60);
                });
            }
            playEarthquake() {
                if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => { });
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, now);
                filter.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.6);
            }
            playGhost() {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(110, now + 0.8);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
            }
            playGel() {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.4);
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, now);
                filter.frequency.linearRampToValueAtTime(100, now + 0.4);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            }
            playHenger() {
                const now = audioCtx.currentTime;
                [2, 4, 6].forEach(delay => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440 * (1 + delay * 0.5), now + delay * 0.02);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    gain.gain.setValueAtTime(0.05, now + delay * 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + delay * 0.02 + 0.1);
                    osc.start(now + delay * 0.02);
                    osc.stop(now + delay * 0.02 + 0.1);
                });
            }
        }
        const sounds = new SoundSystem();

        const SHAPES = {
            'I': [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            'J': [[2, 0, 0], [2, 2, 2], [0, 0, 0]],
            'L': [[0, 0, 3], [3, 3, 3], [0, 0, 0]],
            'O': [[4, 4], [4, 4]],
            'S': [[0, 5, 5], [5, 5, 0], [0, 0, 0]],
            'T': [[0, 6, 0], [6, 6, 6], [0, 0, 0]],
            'Z': [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
        };

        const COLORS = [null, '#22d3ee', '#3b82f6', '#fb923c', '#facc15', '#4ade80', '#a855f7', '#f43f5e'];

        // ÁâπÊÆä„Éü„Éé„ÅÆÁîªÂÉè
        const SPECIAL_IMAGES = {};
        const SPECIAL_TYPES = ['„É¢„Éé„É™„Çπ', '„Ç≤„É´', '„Ç¥„Éº„Çπ„Éà', '„Ç¥„Éº„É¨„É†', '„ÅØ„Å¶„Å™', '„Éò„É≥„Ç¨„Éº'];
        SPECIAL_TYPES.forEach(type => {
            const img = new Image();
            img.src = `images/${type}.png`;
            SPECIAL_IMAGES[type] = img;
        });

        let board = [];
        let boardSpecial = []; // ÁâπÊÆä„Éü„Éé„ÅÆ„Çø„Ç§„Éó„Çí‰øùÊåÅ
        let score = 0;
        let lines = 0;
        let isGameOver = true;
        let dropCounter = 0;
        let dropInterval = 800;
        let lastTime = 0;
        let inventory = null;
        let animationId = null;
        let heldPieceType = null;
        let holdUsed = false;

        // Èï∑Êäº„ÅóÔºàSoft DropÔºâÁî®
        let softDropInterval = null;

        function initBoard() {
            board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
            boardSpecial = Array.from({ length: ROWS }, () => new Array(COLS).fill(null));
        }

        const player = { pos: { x: 0, y: 0 }, matrix: null, type: null, nextType: null, specialType: null, nextSpecialType: null };

        function resize() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            if (!isGameOver) draw();
        }
        window.addEventListener('resize', resize);
        resize();

        function draw() {
            const cellSize = Math.min(canvas.width / COLS, canvas.height / ROWS);
            const offsetX = (canvas.width - cellSize * COLS) / 2;
            const offsetY = (canvas.height - cellSize * ROWS) / 2;

            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(offsetX + x * cellSize, offsetY);
                ctx.lineTo(offsetX + x * cellSize, offsetY + ROWS * cellSize);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + y * cellSize);
                ctx.lineTo(offsetX + COLS * cellSize, offsetY + y * cellSize);
                ctx.stroke();
            }

            if (player.matrix && !isGameOver) {
                const ghostPos = getGhostPosition();
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                            ctx.strokeRect(offsetX + (ghostPos.x + x) * cellSize + 2, offsetY + (ghostPos.y + y) * cellSize + 2, cellSize - 4, cellSize - 4);
                        }
                    });
                });
            }

            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(ctx, x, y, value, cellSize, offsetX, offsetY, boardSpecial[y][x]);
                });
            });

            if (player.matrix) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) drawBlock(ctx, player.pos.x + x, player.pos.y + y, value, cellSize, offsetX, offsetY, player.specialType);
                    });
                });
            }
        }

        function drawBlock(c, x, y, value, size, ox, oy, specialType) {
            if (specialType && SPECIAL_IMAGES[specialType].complete) {
                c.drawImage(SPECIAL_IMAGES[specialType], ox + x * size + 1, oy + y * size + 1, size - 2, size - 2);
            } else {
                c.fillStyle = COLORS[value];
                c.fillRect(ox + x * size + 1, oy + y * size + 1, size - 2, size - 2);
                c.fillStyle = 'rgba(255,255,255,0.2)';
                c.fillRect(ox + x * size + 1, oy + y * size + 1, size - 2, size / 4);
            }
        }

        function drawPreview(c, type, targetCanvas, specialType) {
            c.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            if (!type) return;
            const m = SHAPES[type];
            const size = 8;
            const ox = (targetCanvas.width - m[0].length * size) / 2;
            const oy = (targetCanvas.height - m.length * size) / 2;
            m.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if (specialType && SPECIAL_IMAGES[specialType].complete) {
                            c.drawImage(SPECIAL_IMAGES[specialType], ox + x * size, oy + y * size, size - 1, size - 1);
                        } else {
                            c.fillStyle = COLORS[value];
                            c.fillRect(ox + x * size, oy + y * size, size - 1, size - 1);
                        }
                    }
                });
            });
        }

        function getGhostPosition() {
            const p = { pos: { ...player.pos }, matrix: player.matrix };
            while (!collide(p)) p.pos.y++;
            p.pos.y--;
            return p.pos;
        }

        function collide(p = player) {
            const [m, o] = [p.matrix, p.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (board[y + o.y] === undefined || board[y + o.y][x + o.x] === undefined || board[y + o.y][x + o.x] !== 0)) return true;
                }
            }
            return false;
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            if (!player.nextType) {
                player.nextType = pieces[Math.random() * pieces.length | 0];
                player.nextSpecialType = generateSpecialType();
            }
            player.type = player.nextType;
            player.matrix = SHAPES[player.type];
            player.specialType = player.nextSpecialType;

            player.nextType = pieces[Math.random() * pieces.length | 0];
            player.nextSpecialType = generateSpecialType();

            player.pos.y = 0;
            player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
            holdUsed = false;
            if (collide()) gameOver();
            drawPreview(nextCtx, player.nextType, nextCanvas, player.nextSpecialType);
        }

        function generateSpecialType() {
            const r = Math.random();
            if (r < 0.4) return '„É¢„Éé„É™„Çπ';
            if (r < 0.55) return '„Ç≤„É´';
            if (r < 0.7) return '„Ç¥„Éº„Çπ„Éà';
            if (r < 0.85) return '„Ç¥„Éº„É¨„É†';
            if (r < 0.95) return '„Éò„É≥„Ç¨„Éº';
            return '„ÅØ„Å¶„Å™';
        }

        function holdPiece() {
            if (holdUsed || isGameOver) return;
            const currentType = player.type;
            const currentSpecial = player.specialType;
            if (heldPieceType === null) {
                heldPieceType = currentType;
                heldSpecialType = currentSpecial;
                playerReset();
            } else {
                const tempType = heldPieceType;
                const tempSpecial = heldSpecialType;
                heldPieceType = currentType;
                heldSpecialType = currentSpecial;
                player.type = tempType;
                player.matrix = SHAPES[player.type];
                player.specialType = tempSpecial;
                player.pos.y = 0;
                player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
            }
            holdUsed = true;
            drawPreview(holdCtx, heldPieceType, holdCanvas, heldSpecialType);
            draw();
        }
        let heldSpecialType = null;

        function playerDrop() {
            player.pos.y++;
            if (collide()) {
                player.pos.y--;
                merge();
                playerReset();
                sweep();
                updateStats();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide()) player.pos.x -= dir;
            draw();
        }

        function rotateMatrix(matrix) {
            const m = matrix.map(row => [...row]);
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
                }
            }
            m.forEach(row => row.reverse());
            return m;
        }

        function playerRotate() {
            if (player.specialType === '„Éò„É≥„Ç¨„Éº') {
                const pieces = 'ILJOTSZ';
                const nextShape = pieces[Math.floor(Math.random() * pieces.length)];
                const oldMatrix = player.matrix;

                // Êñ∞„Åó„ÅÑÂΩ¢Áä∂„ÇíÂèñÂæó
                let newMatrix = SHAPES[nextShape];

                // 0„Äú3Âõû„ÅÆ„É©„É≥„ÉÄ„É†„Å™ÂõûËª¢„ÇíÈÅ©Áî®
                const rotations = Math.floor(Math.random() * 4);
                for (let i = 0; i < rotations; i++) {
                    newMatrix = rotateMatrix(newMatrix);
                }

                player.matrix = newMatrix;
                if (collide()) {
                    player.matrix = oldMatrix;
                } else {
                    sounds.playHenger();
                }
                draw();
                return;
            }

            const m = rotateMatrix(player.matrix);
            const oldM = player.matrix;
            player.matrix = m;
            if (collide()) {
                player.matrix = oldM;
            }
            draw();
        }

        function hardDrop() {
            while (!collide()) player.pos.y++;
            player.pos.y--;
            playerDrop();
            draw();
        }

        function merge() {
            const affectedCells = [];
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const bx = x + player.pos.x;
                        const by = y + player.pos.y;
                        board[by][bx] = value;
                        boardSpecial[by][bx] = player.specialType;
                        affectedCells.push({ x: bx, y: by });
                    }
                });
            });

            if (player.specialType) {
                handleSpecialEffect(affectedCells, player.specialType);
                if (player.specialType === '„Ç≤„É´') sounds.playGel();
            }

            if (inventory?.active) {
                if (inventory.id === 'bomb') {
                    const px = player.pos.x, py = player.pos.y;
                    for (let y = -2; y < 4; y++) {
                        for (let x = -2; x < 4; x++) {
                            if (board[py + y]?.[px + x] !== undefined) {
                                board[py + y][px + x] = 0;
                                boardSpecial[py + y][px + x] = null;
                            }
                        }
                    }
                }
                inventory = null;
                updateItemUI();
            }
        }

        function handleSpecialEffect(cells, type) {
            let effectType = type;
            if (type === '„ÅØ„Å¶„Å™') {
                const types = ['„Ç≤„É´', '„Ç¥„Éº„Çπ„Éà', '„Ç¥„Éº„É¨„É†', '„É¢„Éé„É™„Çπ'];
                effectType = types[Math.floor(Math.random() * types.length)];
            }

            if (effectType === '„Ç¥„Éº„Çπ„Éà') {
                sounds.playGhost();
                cells.forEach(cell => {
                    // „Éü„ÉéËá™Ë∫´„ÇíÊ∂àÂéª
                    board[cell.y][cell.x] = 0;
                    boardSpecial[cell.y][cell.x] = null;
                    // Êé•Âú∞ÁÆáÊâÄÔºàÁõ¥‰∏ãÔºâ„ÇíÊ∂àÂéª
                    if (board[cell.y + 1] && board[cell.y + 1][cell.x] !== undefined) {
                        board[cell.y + 1][cell.x] = 0;
                        boardSpecial[cell.y + 1][cell.x] = null;
                    }
                });
            } else if (effectType === '„Ç¥„Éº„É¨„É†') {
                // „Çª„É´„ÇíYÂ∫ßÊ®ô„ÅÆÂ§ß„Åç„ÅÑÈ†ÜÔºà‰∏ã„Åã„ÇâÈ†ÜÔºâ„Å´„ÇΩ„Éº„Éà„Åó„Å¶Âá¶ÁêÜ
                const sortedCells = [...cells].sort((a, b) => b.y - a.y);

                sortedCells.forEach(cell => {
                    let targetY = -1;
                    // Áúü‰∏ã„Å´„ÅÇ„ÇãÊúÄÂàù„ÅÆÈöôÈñì„ÇíÊé¢„Åô
                    for (let y = cell.y + 1; y < ROWS; y++) {
                        if (board[y][cell.x] === 0) {
                            targetY = y;
                            break;
                        }
                    }

                    if (targetY !== -1) {
                        // cell.y„Åã„ÇâtargetY„ÅÆÁõ¥Ââç„Åæ„Åß„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí1ÊÆµ„Åö„Å§Êäº„Åó‰∏ã„Åí„Çã
                        for (let y = targetY; y > cell.y; y--) {
                            board[y][cell.x] = board[y - 1][cell.x];
                            boardSpecial[y][cell.x] = boardSpecial[y - 1][cell.x];
                        }
                        board[cell.y][cell.x] = 0;
                        boardSpecial[cell.y][cell.x] = null;
                    }
                });

                // Ë®≠ÁΩÆÊôÇ„ÅØÂ∏∏„Å´SE„Å®Êè∫„ÇåÊºîÂá∫„ÇíË°å„ÅÜ
                sounds.playEarthquake();
                const wrapper = document.getElementById('canvas-wrapper');
                wrapper.classList.remove('shake');
                void wrapper.offsetWidth;
                wrapper.classList.add('shake');
            }
        }

        function sweep() {
            let cleared = 0;
            outer: for (let y = board.length - 1; y >= 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                    if (board[y][x] === 0) continue outer;
                    // „Ç≤„É´„ÅåËêΩ‰∏ã‰∏≠„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„É©„Ç§„É≥„ÇíÊ∂à„Åï„Å™„ÅÑ
                    if (boardSpecial[y][x] === '„Ç≤„É´' && board[y + 1] && board[y + 1][x] === 0) continue outer;
                    // Áõ§Èù¢ÂÖ®‰Ωì„Å´ËêΩ‰∏ã‰∏≠„ÅÆ„Ç≤„É´„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà„Çà„ÇäÂé≥ÂØÜ„Å™Âà∂Âæ°Ôºâ
                }
                // ËêΩ‰∏ã‰∏≠„ÅÆ„Ç≤„É´„Åå1„Å§„Åß„ÇÇ„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„É©„Ç§„É≥Ê∂àÂéªËá™‰Ωì„Çí‰øùÁïô„Åô„Çã
                for (let ry = 0; ry < ROWS; ry++) {
                    for (let rx = 0; rx < COLS; rx++) {
                        if (boardSpecial[ry][rx] === '„Ç≤„É´' && board[ry + 1] && board[ry + 1][rx] === 0) continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                const rowS = boardSpecial.splice(y, 1)[0].fill(null);
                board.unshift(row);
                boardSpecial.unshift(rowS);
                ++y;
                cleared++;
            }
            if (cleared > 0) {
                lines += cleared;
                if (cleared === 4) {
                    score += 2000;
                    sounds.playTetrisBonus();
                } else {
                    score += [0, 100, 300, 500, 800][cleared];
                    sounds.playLineClear();
                }
                grantItem(); // „Ç¢„Ç§„ÉÜ„É†„ÅØ„É©„Ç§„É≥Ê∂àÂéª„ÅÆ„Åü„Å≥„Å´Âá∫„Çã„Çà„ÅÜ„Å´
            }
        }

        function grantItem() {
            const r = Math.random();
            let selectedItem;
            if (r < 0.45) {
                selectedItem = { id: 'bomb', name: 'BOMB' };
            } else if (r < 0.90) {
                selectedItem = { id: 'slow', name: 'SLOW' };
            } else {
                selectedItem = { id: 'clear', name: 'CLEAR' };
            }
            inventory = { ...selectedItem, active: false };
            updateItemUI();
        }

        function useItem() {
            if (!inventory || inventory.active) return;
            if (inventory.id === 'bomb') {
                inventory.active = true;
                updateItemUI();
            } else if (inventory.id === 'slow') {
                const old = dropInterval; dropInterval = 2000;
                setTimeout(() => dropInterval = old, 8000);
                inventory = null; updateItemUI();
            } else if (inventory.id === 'clear') {
                initBoard(); inventory = null; updateItemUI();
            }
        }

        // „Ç≤„É´„ÅÆÁâπÊÆäÂá¶ÁêÜÔºà„Å®„Çç„Åë„ÇãÔºâ
        let lastGelUpdate = 0;
        function updateGels(time) {
            if (time - lastGelUpdate < 500) return;
            lastGelUpdate = time;
            let moved = false;
            for (let y = ROWS - 2; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (boardSpecial[y][x] === '„Ç≤„É´' && board[y + 1][x] === 0) {
                        board[y + 1][x] = board[y][x];
                        boardSpecial[y + 1][x] = boardSpecial[y][x];
                        board[y][x] = 0;
                        boardSpecial[y][x] = null;
                        moved = true;
                    }
                }
            }
            if (moved) {
                sweep();
                updateStats();
                draw();
            }
        }

        function updateItemUI() {
            const btn = document.getElementById('btn-item');
            const name = document.getElementById('item-name');

            // ÂÖ®„Ç´„É©„Éº„ÇØ„É©„Çπ„Çí„É™„Çª„ÉÉ„Éà
            btn.classList.remove('bg-amber-500', 'bg-emerald-500', 'bg-indigo-500', 'bg-amber-500');
            btn.style.backgroundColor = '';

            if (inventory) {
                name.innerText = inventory.name;
                if (inventory.id === 'bomb') btn.style.backgroundColor = '#f59e0b'; // bg-amber-500
                if (inventory.id === 'slow') btn.style.backgroundColor = '#10b981'; // bg-emerald-500
                if (inventory.id === 'clear') btn.style.backgroundColor = '#6366f1'; // bg-indigo-500

                if (inventory.active) btn.classList.add('item-active');
                else btn.classList.remove('item-active');
            } else {
                name.innerText = 'NONE';
                btn.classList.remove('item-active');
            }
        }

        function updateStats() {
            document.getElementById('score').innerText = score;
            document.getElementById('lines').innerText = lines;
            dropInterval = Math.max(80, 800 - (Math.floor(lines / 2) * 80));
        }

        // Score History
        function saveToStorage() {
            const best = localStorage.getItem('tetris_best_score') || 0;
            if (score > best) {
                localStorage.setItem('tetris_best_score', score);
            }
        }

        function showBestScore() {
            const best = localStorage.getItem('tetris_best_score');
            if (best) {
                document.getElementById('best-score').innerText = best;
                document.getElementById('best-score-container').classList.remove('hidden');
            }
        }

        function gameOver() {
            isGameOver = true;
            sounds.stopBGM();
            saveToStorage();
            showBestScore();
            if (softDropInterval) {
                clearInterval(softDropInterval);
                softDropInterval = null;
            }
            cancelAnimationFrame(animationId);
            overlay.style.display = 'flex';
        }

        function update(time = 0) {
            if (isGameOver) return;
            const dt = time - lastTime;
            lastTime = time;
            dropCounter += dt;
            if (dropCounter > dropInterval) playerDrop();
            updateGels(time);
            draw();
            animationId = requestAnimationFrame(update);
        }

        function start() {
            initBoard(); score = 0; lines = 0; dropInterval = 800; inventory = null;
            isGameOver = false; player.nextType = null; player.nextSpecialType = null; heldPieceType = null; heldSpecialType = null; holdUsed = false;
            overlay.style.display = 'none';
            sounds.playBGM();
            updateStats(); updateItemUI(); playerReset(); drawPreview(holdCtx, null, holdCanvas, null);
            resize(); lastTime = performance.now(); update();
        }

        // „Ç§„Éô„É≥„Éà„Éê„Ç§„É≥„Éâ„Éò„É´„Éë„ÉºÔºà‰∏ã„Éú„Çø„É≥Èï∑Êäº„ÅóÂØæÂøúÔºâ
        const bind = (id, options) => {
            const el = document.getElementById(id);

            if (id === 'btn-down') {
                const startSoftDrop = (e) => {
                    e.preventDefault();
                    if (isGameOver) return;
                    playerDrop();
                    if (!softDropInterval) {
                        softDropInterval = setInterval(() => {
                            playerDrop();
                        }, 50); // 50msÈñìÈöî„ÅßËêΩ‰∏ã
                    }
                };
                const stopSoftDrop = (e) => {
                    if (softDropInterval) {
                        clearInterval(softDropInterval);
                        softDropInterval = null;
                    }
                };
                el.addEventListener('touchstart', startSoftDrop);
                el.addEventListener('mousedown', startSoftDrop);
                el.addEventListener('touchend', stopSoftDrop);
                el.addEventListener('mouseup', stopSoftDrop);
                el.addEventListener('mouseleave', stopSoftDrop);
            } else {
                const trigger = (e) => {
                    e.preventDefault();
                    if (!isGameOver || id === 'start-btn') options.fn();
                };
                el.addEventListener('touchstart', trigger);
                el.addEventListener('mousedown', trigger);
            }
        };

        bind('btn-left', { fn: () => playerMove(-1) });
        bind('btn-right', { fn: () => playerMove(1) });
        bind('btn-rotate', { fn: () => playerRotate() });
        bind('btn-down', {}); // ÁâπÊÆäÂá¶ÁêÜ
        bind('btn-drop', { fn: () => hardDrop() });
        bind('btn-item', { fn: () => useItem() });
        bind('btn-hold', { fn: () => holdPiece() });
        document.getElementById('start-btn').onclick = start;

        const goToNeonDash = () => {
            window.location.href = '../neon_dash/index.html';
        };
        document.getElementById('switch-left').onclick = goToNeonDash;
        document.getElementById('switch-right').onclick = goToNeonDash;

        // Modal Events
        const helpModal = document.getElementById('help-modal');
        document.getElementById('help-btn').onclick = () => helpModal.style.display = 'flex';
        document.getElementById('close-modal').onclick = () => helpModal.style.display = 'none';
        window.onclick = (e) => { if (e.target == helpModal) helpModal.style.display = 'none'; };

        // BGM Toggle
        const bgmBtn = document.getElementById('bgm-toggle');
        const updateBGMUI = () => {
            if (sounds.isMuted) {
                bgmBtn.innerText = 'üîá';
                bgmBtn.classList.add('muted');
            } else {
                bgmBtn.innerText = 'üîä';
                bgmBtn.classList.remove('muted');
            }
        };
        bgmBtn.onclick = () => {
            sounds.toggleMute();
            updateBGMUI();
        };
        updateBGMUI();

        showBestScore();
        initBoard();
        draw();
    </script>

</body>

</html>