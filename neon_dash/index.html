<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON DASH - Music Edition</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff00de;
            --neon-gold: #ffcc00;
            --neon-slow: #00ff88;
            --neon-zigzag: #ffff00;
            --neon-scale: #88ff00;
            --neon-blink: #ffffff;
            --bg-color: #0a0a0c;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 5;
        }

        #score {
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 0 0 15px var(--neon-blue);
            margin: 0;
            text-align: center;
        }

        #level-indicator {
            font-size: 1rem;
            color: var(--neon-blue);
            letter-spacing: 2px;
            text-align: center;
        }

        #combo {
            font-size: 1.2rem;
            color: var(--neon-pink);
            font-weight: bold;
            opacity: 0;
            text-align: center;
            transition: opacity 0.2s;
        }

        #combo.active {
            opacity: 1;
        }

        #slow-gauge-container {
            position: absolute;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #slow-gauge {
            width: 100%;
            height: 100%;
            background: var(--neon-slow);
            box-shadow: 0 0 10px var(--neon-slow);
            transform-origin: left;
        }

        #slow-gauge-container.active {
            opacity: 1;
        }

        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 12, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            font-size: 3rem;
            margin: 0 0 10px;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            font-style: italic;
        }

        /* BGM Toggle Button */
        #bgm-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: 0.2s;
        }

        #bgm-toggle:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #bgm-toggle.muted {
            border-color: #555;
            color: #555;
        }

        /* Ranking Modal/List Improvements */
        #leaderboard {
            width: 100%;
            max-width: 350px;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            font-size: 0.85rem;
            max-height: 250px;
            /* Scrollable area */
            overflow-y: auto;
            border: 1px solid rgba(0, 242, 255, 0.2);
        }

        /* Custom Scrollbar for Ranking */
        #leaderboard::-webkit-scrollbar {
            width: 8px;
        }

        #leaderboard::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        #leaderboard::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-entry:last-child {
            border-bottom: none;
        }

        .btn-secondary {
            border-color: var(--neon-gold);
            font-size: 1rem;
            padding: 10px 30px;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background: var(--neon-gold);
            box-shadow: 0 0 20px var(--neon-gold);
        }

        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-blue);
            color: white;
            padding: 10px;
            font-size: 1.2rem;
            border-radius: 5px;
            width: 200px;
            text-align: center;
            margin-bottom: 20px;
            outline: none;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            background: transparent;
            color: white;
            border: 2px solid var(--neon-blue);
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: 0.2s;
        }

        .btn:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        #main-button {
            margin-bottom: 20px;
        }

        #leaderboard {
            width: 100%;
            max-width: 300px;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            font-size: 0.85rem;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .is-me {
            color: var(--neon-blue);
            font-weight: bold;
        }

        #msg-overlay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px var(--neon-pink);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }

        @keyframes popOut {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }

            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.0);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div>
                <div id="level-indicator">LEVEL 1</div>
                <div id="score">0</div>
                <div id="combo">NEAR MISS x1</div>
            </div>
            <div id="slow-gauge-container">
                <div id="slow-gauge"></div>
            </div>
        </div>

        <div id="msg-overlay">READY...</div>

        <div id="overlay-screen">
            <h1 id="screen-title">NEON DASH</h1>
            <p id="screen-subtitle" style="color:#aaa; font-size: 0.8rem; margin-bottom: 20px;">ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Çπ„Çø„Éº„Éà</p>

            <input type="text" id="player-name" placeholder="YOUR NAME" maxlength="10">

            <div id="leaderboard" class="hidden">
                <div style="font-weight: bold; margin-bottom: 10px; color: var(--neon-gold);">GLOBAL RANKING</div>
                <div id="leaderboard-list">Loading...</div>
            </div>

            <button id="main-button" class="btn">START GAME</button>
            <button id="home-button" class="btn btn-secondary hidden">HOME</button>
            <button id="ranking-button" class="btn btn-secondary">RANKING (TOP 30)</button>
        </div>

        <div id="bgm-toggle">üîä</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, limit, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- FirebaseË®≠ÂÆö ---
        let firebaseConfig;
        try {
            firebaseConfig = JSON.parse(__firebase_config);
        } catch (e) {
            firebaseConfig = {
                apiKey: "AIzaSyBpnRNS5MDXn6_3PuWsYlUZs6Kl-SJAlko",
                authDomain: "neon-dash-db.firebaseapp.com",
                projectId: "neon-dash-db",
                storageBucket: "neon-dash-db.firebasestorage.app",
                messagingSenderId: "205106729402",
                appId: "1:205106729402:web:20b827387f1c0e24444d83"
            };
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'neon-dash-v3';

        let user = null;
        const authenticate = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        onAuthStateChanged(auth, (u) => {
            user = u;
            if (u) loadRanking();
        });
        authenticate();

        // --- Sound Setup (Synthesized BGM) ---
        // Â§ñÈÉ®„Éï„Ç°„Ç§„É´„Å´‰æùÂ≠ò„Åõ„Åö„ÄÅWeb Audio API„ÅßÈü≥„ÇíÁîüÊàê„Åó„Åæ„Åô
        // Github PagesÁ≠â„Åß„ÅÆCORS/404ÂïèÈ°å„ÇíÂõûÈÅø„Åô„Çã„Åü„ÇÅ„Ç∑„É≥„Çª„Çµ„Ç§„Ç∂„Éº„Çí‰ΩøÁî®
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        class BGMSystem {
            constructor() {
                this.isPlaying = false;
                this.timerID = null;
                this.tempo = 120; // BPM
                this.volume = 0.1;
                this.playbackRate = 1.0;
                this.currentNote = 0;
                this.isMuted = localStorage.getItem('neon_dash_bgm_muted') === 'true';

                // Simple Cyberpunk Bassline
                this.melody = [
                    { f: 110, d: 0.25 }, { f: 0, d: 0.25 }, { f: 110, d: 0.25 }, { f: 0, d: 0.25 },
                    { f: 130.8, d: 0.25 }, { f: 0, d: 0.25 }, { f: 130.8, d: 0.25 }, { f: 0, d: 0.25 },
                    { f: 98, d: 0.25 }, { f: 0, d: 0.25 }, { f: 98, d: 0.25 }, { f: 0, d: 0.25 },
                    { f: 110, d: 0.25 }, { f: 0, d: 0.25 }, { f: 110, d: 0.25 }, { f: 0, d: 0.25 }
                ];
            }

            async play() {
                if (this.isPlaying || this.isMuted) return;
                // AudioContext must be resumed inside a user gesture (which start() is)
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                this.isPlaying = true;
                this.loop();
            }

            pause() {
                this.stop();
            }

            stop() {
                this.isPlaying = false;
                if (this.timerID) clearTimeout(this.timerID);
            }

            loop() {
                if (!this.isPlaying || this.isMuted) return;

                const note = this.melody[this.currentNote];
                let duration = note.d / this.playbackRate;

                if (note.f > 0) this.tone(note.f, duration * 0.8);

                this.currentNote = (this.currentNote + 1) % this.melody.length;

                const interval = (note.d * 1000) / this.playbackRate;
                this.timerID = setTimeout(() => this.loop(), interval);
            }

            tone(freq, dur) {
                if (this.isMuted) return; // Mute check

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

                // Lowpass filter for "dark" synth sound
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 600;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(this.volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + dur);

                osc.start(now);
                osc.stop(now + dur + 0.1);
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('neon_dash_bgm_muted', this.isMuted);
                if (this.isMuted) {
                    this.stop();
                    return true;
                } else {
                    if (gameState === 'PLAYING') this.play();
                    return false;
                }
            }

            // Sound Effects - Play even if BGM is muted (unless requested otherwise, but typically SE acts independently)
            playSE(type) {
                if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => { });

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const now = audioCtx.currentTime;

                if (type === 'gold') {
                    // Coin/gem sound: High sine ping
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, now);
                    osc.frequency.exponentialRampToValueAtTime(1800, now + 0.1);

                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now);
                    osc.stop(now + 0.3);
                } else if (type === 'slow') {
                    // Powerup: Sweep
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(220, now);
                    osc.frequency.linearRampToValueAtTime(880, now + 0.3);

                    // Filter sweep
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(500, now);
                    filter.frequency.linearRampToValueAtTime(3000, now + 0.3);

                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 0.3);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now);
                    osc.stop(now + 0.3);
                }
            }
        }

        const bgm = new BGMSystem();

        // --- Game Logic ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const comboElement = document.getElementById('combo');
        const levelElement = document.getElementById('level-indicator');
        const slowGaugeContainer = document.getElementById('slow-gauge-container');
        const slowGauge = document.getElementById('slow-gauge');
        const msgOverlay = document.getElementById('msg-overlay');
        const overlayScreen = document.getElementById('overlay-screen');
        const mainButton = document.getElementById('main-button');
        const playerNameInput = document.getElementById('player-name');
        const leaderboardDiv = document.getElementById('leaderboard');
        const screenTitle = document.getElementById('screen-title');
        const bgmToggle = document.getElementById('bgm-toggle');
        const rankingButton = document.getElementById('ranking-button');

        let gameState = 'START_MENU';
        let score = 0, combo = 0, level = 1, speed = 5, distance = 0, slowTime = 0;
        let player, obstacles = [], items = [], particles = [];
        const BEHAVIOR_TYPES = ['static', 'horizontal', 'zigzag', 'scale', 'blink'];

        const PLAYER_SIZE = 35;
        const SLOW_DURATION = 300;

        // Initialize Images
        const imgPlayer = new Image(); imgPlayer.src = 'img/player.png';
        const imgItemYellow = new Image(); imgItemYellow.src = 'img/yellow.png';
        const imgItemGreen = new Image(); imgItemGreen.src = 'img/green.png';

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height * 0.8;
                this.targetX = this.x;
            }
            update() { this.x += (this.targetX - this.x) * 0.25; }
            draw() {
                // Use image instead of rect
                if (imgPlayer.complete) {
                    ctx.shadowBlur = 15; ctx.shadowColor = "#00f2ff";
                    // Draw centered
                    ctx.drawImage(imgPlayer, this.x - PLAYER_SIZE / 2, this.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
                    ctx.shadowBlur = 0;
                } else {
                    // Fallback if image not loaded yet
                    ctx.fillStyle = "#00f2ff";
                    ctx.fillRect(this.x - PLAYER_SIZE / 2, this.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
                }
            }
            move(dir) {
                const lane = canvas.width / 3.5;
                if (dir === 'left') this.targetX = Math.max(PLAYER_SIZE, this.targetX - lane);
                else this.targetX = Math.min(canvas.width - PLAYER_SIZE, this.targetX + lane);
            }
        }

        class Obstacle {
            constructor() {
                this.w = canvas.width * (0.2 + Math.random() * 0.2);
                this.h = 35;
                this.x = Math.random() * (canvas.width - this.w);
                this.y = -100;
                this.passed = false;
                this.baseX = this.x;
                this.time = 0;

                // „É¨„Éô„É´„Å´Âøú„Åò„Å¶ÊåôÂãï„ÅÆÁ®ÆÈ°û„ÇíÂ¢ó„ÇÑ„Åô
                // level 1: static, level 2: static+horizontal, ... level 5: all
                const maxBehaviorIndex = Math.min(level, BEHAVIOR_TYPES.length) - 1;
                this.type = BEHAVIOR_TYPES[Math.floor(Math.random() * (maxBehaviorIndex + 1))];

                // ÊåôÂãï„Å´Âøú„Åò„ÅüÂàùÊúüË®≠ÂÆö
                this.seed = Math.random() * Math.PI * 2;
                this.blinkTimer = 0;
                this.visible = true;
            }
            update(s) {
                this.y += s;
                this.time++;

                if (this.type === 'horizontal') {
                    this.x = this.baseX + Math.sin(this.time * 0.05 + this.seed) * (canvas.width * 0.2);
                    // ÁîªÈù¢Á´Ø„ÅÆÊâãÂΩì
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
                } else if (this.type === 'zigzag') {
                    this.x = this.baseX + Math.sin(this.time * 0.1 + this.seed) * (canvas.width * 0.1);
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
                } else if (this.type === 'scale') {
                    const scale = 1 + Math.sin(this.time * 0.08 + this.seed) * 0.3;
                    const center = this.x + this.w / 2;
                    this.w = (canvas.width * 0.3) * scale;
                    this.x = center - this.w / 2;
                } else if (this.type === 'blink') {
                    this.blinkTimer++;
                    if (this.blinkTimer % 20 === 0) this.visible = !this.visible;
                }
            }
            draw() {
                if (!this.visible) return;

                let color = "#ff00de"; // static (pink)
                if (this.type === 'horizontal') color = "#00f2ff"; // cyan
                else if (this.type === 'zigzag') color = "#ffff00"; // yellow
                else if (this.type === 'scale') color = "#88ff00"; // green-yellow
                else if (this.type === 'blink') color = "#ffffff"; // white

                ctx.fillStyle = color;
                ctx.shadowBlur = 10; ctx.shadowColor = color;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.shadowBlur = 0;
            }
        }

        class Item {
            constructor(type) {
                this.type = type;
                this.size = 30; // Slightly larger for images
                this.x = Math.random() * (canvas.width - this.size);
                this.y = -100;
            }
            update(s) { this.y += s * 1.2; }
            draw() {
                const img = this.type === 'gold' ? imgItemYellow : imgItemGreen;
                const glow = this.type === 'gold' ? "#ffcc00" : "#00ff88";

                if (img.complete) {
                    ctx.shadowBlur = 15; ctx.shadowColor = glow;
                    ctx.drawImage(img, this.x, this.y, this.size, this.size);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = glow;
                    ctx.shadowBlur = 15; ctx.shadowColor = glow;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.shadowBlur = 0;
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 10; this.vy = (Math.random() - 0.5) * 10;
                this.life = 1.0;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; }
            draw() {
                ctx.fillStyle = this.color.replace(')', `, ${this.life})`).replace('rgb', 'rgba');
                ctx.fillRect(this.x, this.y, 3, 3);
            }
        }

        const showMsg = (txt) => {
            msgOverlay.innerText = txt;
            msgOverlay.style.animation = 'none';
            void msgOverlay.offsetWidth;
            msgOverlay.style.animation = 'popOut 1s forwards';
        };

        const saveScore = async () => {
            const name = playerNameInput.value.trim() || "GUEST";
            if (!user) return;
            try {
                const col = collection(db, 'artifacts', appId, 'public', 'data', 'scores');
                await addDoc(col, { name: name, uid: user.uid, score: Math.floor(score), date: Date.now() });
                loadRanking();
            } catch (e) { console.error("Score save error:", e); }
        };



        const loadRanking = async (limitCount = 30) => {
            const list = document.getElementById('leaderboard-list');
            list.innerText = "Loading...";
            try {
                const col = collection(db, 'artifacts', appId, 'public', 'data', 'scores');
                const p = query(col, orderBy("score", "desc"), limit(limitCount));
                const snap = await getDocs(p);
                let results = [];
                snap.forEach(d => results.push(d.data()));

                // Client-side deduping if needed or simple display
                // results.sort((a, b) => b.score - a.score); // Already ordered by query

                list.innerHTML = results.map((r, i) => `
                <div class="leaderboard-entry ${r.uid === user?.uid ? 'is-me' : ''}">
                    <span>${i + 1}. ${r.name}</span>
                    <span>${r.score}</span>
                </div>
            `).join('') || "No scores yet";
            } catch (e) {
                list.innerText = "Ranking error";
                console.error(e);
            }
        };

        function update() {
            if (gameState !== 'PLAYING') {
                if (player) player.update();
                return;
            }

            let curSpeed = speed;
            if (slowTime > 0) {
                curSpeed *= 0.5;
                slowTime--;
                slowGaugeContainer.classList.add('active');
                slowGauge.style.transform = `scaleX(${slowTime / SLOW_DURATION})`;
                bgm.playbackRate = 0.8; // „Çπ„É≠„Éº‰∏≠„ÅØÊõ≤„ÅÆ„ÉÜ„É≥„Éù„ÇÇËêΩ„Å®„ÅôÊºîÂá∫
            } else {
                slowGaugeContainer.classList.remove('active');
                bgm.playbackRate = 1.0;
            }

            distance++;
            player.update();

            const targetLevel = Math.floor(score / 1000) + 1;
            if (targetLevel > level) {
                level = targetLevel;
                // ÂÖ®„Å¶„ÅÆ„É¢„Éº„Éâ„ÅåËß£Êîæ„Åï„Çå„ÅüÔºà„É¨„Éô„É´ > ÊåôÂãïÊï∞ÔºâÂæå„ÄÅ„Çπ„Éî„Éº„Éâ„Ç¢„ÉÉ„Éó„ÇíÈñãÂßã
                if (level > BEHAVIOR_TYPES.length) {
                    speed += 0.4;
                }
                levelElement.innerText = `LEVEL ${level}`;
                showMsg("LEVEL UP!"); // SPEED UP„Åã„ÇâLEVEL UP„Å´Â§âÊõ¥
            }

            if (distance % (Math.max(15, 60 - level) * (slowTime > 0 ? 2 : 1)) === 0) obstacles.push(new Obstacle());
            if (distance % 400 === 0) items.push(new Item('gold'));
            if (distance % 700 === 0) items.push(new Item('slow'));

            obstacles.forEach((o, i) => {
                o.update(curSpeed);
                if (player.x + 12 > o.x && player.x - 12 < o.x + o.w && player.y + 12 > o.y && player.y - 12 < o.y + o.h) endGame();
                if (!o.passed && o.y > player.y) {
                    o.passed = true;
                    const d = Math.min(Math.abs(player.x - o.x), Math.abs(player.x - (o.x + o.w)));
                    if (d < 50) {
                        combo++; score += 20 * combo;
                        comboElement.innerText = `NEAR MISS x${combo}`;
                        comboElement.classList.add('active');
                    } else { score += 10; }
                    scoreElement.innerText = score;
                }
                if (o.y > canvas.height) obstacles.splice(i, 1);
            });

            items.forEach((it, i) => {
                it.update(curSpeed);
                if (Math.hypot(player.x - it.x, player.y - it.y) < 40) {
                    items.splice(i, 1);
                    if (it.type === 'gold') {
                        score += 500;
                        showMsg("+500!");
                        bgm.playSE('gold'); // Play SE
                    }
                    else {
                        slowTime = SLOW_DURATION;
                        showMsg("SLOW!");
                        bgm.playSE('slow'); // Play SE
                    }
                    scoreElement.innerText = score;
                }
                if (it.y > canvas.height) items.splice(i, 1);
            });

            particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) particles.splice(i, 1);
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 12, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            obstacles.forEach(o => o.draw());
            items.forEach(it => it.draw());
            particles.forEach(p => p.draw());
            if (player) player.draw();
        }

        function gameLoop() {
            update(); draw();
            requestAnimationFrame(gameLoop);
        }

        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };

        const start = () => {
            // Force resize to fix visibility bug on some devices/iframes
            resizeCanvas();

            // BGMÂÜçÁîüÈñãÂßã
            bgm.play().catch(e => console.log("Audio play prevented"));

            score = 0; level = 1; speed = 6; distance = 0; combo = 0; slowTime = 0;
            scoreElement.innerText = "0";
            levelElement.innerText = "LEVEL 1";
            comboElement.classList.remove('active');
            obstacles = []; items = []; particles = [];
            player = new Player();
            gameState = 'READY';
            overlayScreen.classList.add('hidden');
            showMsg("READY...");
            setTimeout(() => { if (gameState === 'READY') { gameState = 'PLAYING'; showMsg("GO!"); } }, 1000);
        };

        const endGame = () => {
            gameState = 'GAMEOVER';
            bgm.playbackRate = 0.5; // „ÇØ„É©„ÉÉ„Ç∑„É•ÊÑü„ÇíÂá∫„Åô„Åü„ÇÅ„Å´„Éî„ÉÉ„ÉÅ„Çí‰∏ã„Åí„Çã
            screenTitle.innerText = "CRASHED";
            screenTitle.style.color = "var(--neon-pink)";
            document.getElementById('screen-subtitle').innerText = `FINAL SCORE: ${score}`;
            playerNameInput.classList.add('hidden');
            leaderboardDiv.classList.remove('hidden');
            mainButton.innerText = "RETRY";
            document.getElementById('home-button').classList.remove('hidden'); // HOME„Éú„Çø„É≥Ë°®Á§∫
            rankingButton.classList.add('hidden'); // Hide simple ranking button on game over
            overlayScreen.classList.remove('hidden');
            saveScore();
        };

        const handleInput = (e) => {
            if (gameState !== 'PLAYING' && gameState !== 'READY') return;

            // Prevent scrolling/zooming
            if (e.cancelable && e.type !== 'mousedown') e.preventDefault();

            let clientX;
            if (e.type === 'touchstart' || e.type === 'touchmove') {
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                } else { return; }
            } else {
                clientX = e.clientX;
            }

            if (clientX < canvas.width / 2) player.move('left');
            else player.move('right');
        };

        window.addEventListener('resize', resizeCanvas);

        // Use canvas listeners for better iframe/mobile support
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        // Touchmove removed to prevent erratic sliding controls
        canvas.addEventListener('mousedown', handleInput);

        // Backup for missed touches
        document.body.addEventListener('touchstart', (e) => {
            if (e.target !== canvas && gameState === 'PLAYING') e.preventDefault();
        }, { passive: false });

        mainButton.addEventListener('click', () => {
            if (gameState === 'START_MENU' || gameState === 'GAMEOVER') start();
        });

        document.getElementById('home-button').addEventListener('click', () => {
            gameState = 'START_MENU';
            screenTitle.innerText = "NEON DASH";
            screenTitle.style.color = "white";
            document.getElementById('screen-subtitle').innerText = "ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Çπ„Çø„Éº„Éà";
            playerNameInput.classList.remove('hidden');
            leaderboardDiv.classList.add('hidden');
            mainButton.innerText = "START GAME";
            document.getElementById('home-button').classList.add('hidden');
            rankingButton.classList.remove('hidden');
            bgm.playbackRate = 1.0;
        });

        rankingButton.addEventListener('click', () => {
            leaderboardDiv.classList.remove('hidden');
            rankingButton.classList.add('hidden');
            loadRanking(30);
        });

        bgmToggle.addEventListener('click', () => {
            const muted = bgm.toggleMute();
            bgmToggle.innerText = muted ? "üîá" : "üîä";
            bgmToggle.classList.toggle('muted', muted);
        });

        // Initialize BGM toggle state
        if (bgm.isMuted) {
            bgmToggle.innerText = "üîá";
            bgmToggle.classList.add('muted');
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gameLoop();
    </script>
</body>

</html>